package expression.parser;

import expression.*;

public class ExpressionParser implements Parser {
    enum Tokens {
        Operation, Number, Variable, TheEnd, Error
    }


    int i;
    int balance;
    Tokens ct;
    char curr;
    StringBuilder sb;
    boolean end;
    boolean lastTime;
    boolean unary;
    boolean fl;

    public Tokens get_token(String expression) throws ParserException {

        while (i != expression.length() && Character.isWhitespace(expression.charAt(i))) {
            i++;
        }
        if (i == expression.length()) {
            end = true;
            return Tokens.TheEnd;
        }
        curr = expression.charAt(i);
        switch (curr) {
            case '(':
                unary = false;
                balance++;
                i++;
                lastTime = true;
                return Tokens.Operation;
            case ')':
                unary = false;
                i++;
                lastTime = false;
                if (balance == 0) {
                    throw new ParserException("ParserException");
                }
                balance--;
                return Tokens.Operation;
            case '+':
            case '-':
            case '*':
            case '/':
            case 'l':
            case 'p':
//			if (lastTime){
//				throw new ParserException("ParserException");
//			}
                unary = false;
                i++;
                lastTime = true;
                return Tokens.Operation;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                if (!unary) {
                    if (!lastTime) {
                        //System.err.println("6");
                        throw new ParserException("ParserException");
                    }
                }
                sb = new StringBuilder();
                while (i != expression.length() && Character.isDigit((expression.charAt(i)))) {
                    sb.append(expression.charAt(i));
                    i++;
                }
                if (i == expression.length()) {
                    end = true;
                }
                lastTime = false;
                return Tokens.Number;
            default:
                unary = false;
                if (!lastTime) {

                    //System.err.println("7");
                    throw new ParserException("ParserException");
                }
                if (Character.isAlphabetic(curr)) {
                    sb = new StringBuilder();
                    sb.append(curr);
                    ++i;
                    if (i == expression.length()) {
                        end = true;
                    }
                    lastTime = false;
                    return Tokens.Variable;
                } else {
                    //System.err.println("5");
                    throw new ParserException("ParserException");
                }
        }
    }

    private TripleExpression highPriority(String expression, boolean flag) throws ParserException ,OverflowException {
        if (flag && !end) {
            ct = get_token(expression);
        }
        switch (ct) {
            case Number:
                ct = get_token(expression);
                TripleExpression const1;
                if (unary) {
                    unary = false;
                    fl = true;

                    try {
                        const1 = new Const(Integer.parseInt("-" + sb.toString()));
                    } catch (NumberFormatException e) {
                        throw new OverflowException("OverflowException");
                    }
                    return const1;
                } else {
                    try {
                        const1 = new Const(Integer.parseInt(  sb.toString()));
                    } catch (NumberFormatException e) {
                        throw new OverflowException("OverflowException");
                    }
                    return const1;
                }
            case Variable:
                ct = get_token(expression);
                return new Variable(sb.toString());
            case Operation:
                if (curr == '(') {
                    TripleExpression te = lowPriority(expression, true);
                    ct = get_token(expression);
                    return te;
                } else {
                    if (curr == 'l'){
                        i+=4;
                        return new CheckedLog(highPriority(expression,true));
                    }
                    if (curr == 'p'){
                        i+=4;
                        return new CheckedPow(highPriority(expression,true));
                    }
                    if (curr == '-') {
                        unary = true;
                        fl = false;
                        TripleExpression tr = highPriority(expression, true);
                        if (fl) {
                            fl = false;
                            return tr;
                        }
                        return new CheckedNegate(tr);
                    } else {
                        //System.err.println("4");
                        throw new ParserException("ParserException");
                    }
                }
            default:
                // System.err.println("2");
                throw new ParserException("ParserException");
        }
    }

    private TripleExpression midPriority(String expression, boolean flag) throws ParserException, OverflowException {
        TripleExpression first = highPriority(expression, flag);
        while (true) {
            switch (curr) {
                case '*':
                    first = new CheckedMultiply(first, highPriority(expression, true));
                    continue;
                case '/':
                    first = new CheckedDivide(first, highPriority(expression, true));
                    continue;
                default:
                    return first;
            }

        }
    }

    private TripleExpression lowPriority(String expression, boolean flag) throws ParserException , OverflowException {
        TripleExpression first = midPriority(expression, flag);
        while (true) {
            switch (curr) {
                case '+':
                    first = new CheckedAdd(first, midPriority(expression, true));
                    continue;
                case '-':
                    first = new CheckedSubtract(first, midPriority(expression, true));
                    continue;
                default:
                    return first;
            }
        }
    }


    public TripleExpression parse(String expression) throws ParserException, OverflowException {
        //  System.err.println(expression);
        lastTime = true;
        balance = 0;
        i = 0;
        end = false;
        fl = false;
        ct = get_token(expression);
        unary = false;
        if (ct.equals(Tokens.Error)) {
            // System.out.println("1");
            throw new ParserException("ParserException");
        }
        if (ct.equals(Tokens.TheEnd)) {
            return new Const(0);
        }
        TripleExpression te = lowPriority(expression, false);
        if (balance != 0) {
            throw new ParserException("ParserException");
        }
        return te;
    }
}